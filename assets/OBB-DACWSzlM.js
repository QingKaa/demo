import{V as u,aI as v,x as A,W as q,aJ as O,aj as w}from"./OrbitControls-DYZe1cjh.js";const i={c:null,u:[new u,new u,new u],e:[]},a={c:null,u:[new u,new u,new u],e:[]},h=[[],[],[]],e=[[],[],[]],c=[],S=new u,y=new u,m=new u,l=new u,B=new u,b=new u,z=new v,P=new A,d=new q,g=new q,R=new O;class V{constructor(t=new u,o=new u,s=new v){this.center=t,this.halfSize=o,this.rotation=s}set(t,o,s){return this.center=t,this.halfSize=o,this.rotation=s,this}copy(t){return this.center.copy(t.center),this.halfSize.copy(t.halfSize),this.rotation.copy(t.rotation),this}clone(){return new this.constructor().copy(this)}getSize(t){return t.copy(this.halfSize).multiplyScalar(2)}clampPoint(t,o){const s=this.halfSize;l.subVectors(t,this.center),this.rotation.extractBasis(S,y,m),o.copy(this.center);const r=w.clamp(l.dot(S),-s.x,s.x);o.add(S.multiplyScalar(r));const n=w.clamp(l.dot(y),-s.y,s.y);o.add(y.multiplyScalar(n));const f=w.clamp(l.dot(m),-s.z,s.z);return o.add(m.multiplyScalar(f)),o}containsPoint(t){return l.subVectors(t,this.center),this.rotation.extractBasis(S,y,m),Math.abs(l.dot(S))<=this.halfSize.x&&Math.abs(l.dot(y))<=this.halfSize.y&&Math.abs(l.dot(m))<=this.halfSize.z}intersectsBox3(t){return this.intersectsOBB(F.fromBox3(t))}intersectsSphere(t){return this.clampPoint(t.center,b),b.distanceToSquared(t.center)<=t.radius*t.radius}intersectsOBB(t,o=Number.EPSILON){i.c=this.center,i.e[0]=this.halfSize.x,i.e[1]=this.halfSize.y,i.e[2]=this.halfSize.z,this.rotation.extractBasis(i.u[0],i.u[1],i.u[2]),a.c=t.center,a.e[0]=t.halfSize.x,a.e[1]=t.halfSize.y,a.e[2]=t.halfSize.z,t.rotation.extractBasis(a.u[0],a.u[1],a.u[2]);for(let n=0;n<3;n++)for(let f=0;f<3;f++)h[n][f]=i.u[n].dot(a.u[f]);l.subVectors(a.c,i.c),c[0]=l.dot(i.u[0]),c[1]=l.dot(i.u[1]),c[2]=l.dot(i.u[2]);for(let n=0;n<3;n++)for(let f=0;f<3;f++)e[n][f]=Math.abs(h[n][f])+o;let s,r;for(let n=0;n<3;n++)if(s=i.e[n],r=a.e[0]*e[n][0]+a.e[1]*e[n][1]+a.e[2]*e[n][2],Math.abs(c[n])>s+r)return!1;for(let n=0;n<3;n++)if(s=i.e[0]*e[0][n]+i.e[1]*e[1][n]+i.e[2]*e[2][n],r=a.e[n],Math.abs(c[0]*h[0][n]+c[1]*h[1][n]+c[2]*h[2][n])>s+r)return!1;return s=i.e[1]*e[2][0]+i.e[2]*e[1][0],r=a.e[1]*e[0][2]+a.e[2]*e[0][1],!(Math.abs(c[2]*h[1][0]-c[1]*h[2][0])>s+r||(s=i.e[1]*e[2][1]+i.e[2]*e[1][1],r=a.e[0]*e[0][2]+a.e[2]*e[0][0],Math.abs(c[2]*h[1][1]-c[1]*h[2][1])>s+r)||(s=i.e[1]*e[2][2]+i.e[2]*e[1][2],r=a.e[0]*e[0][1]+a.e[1]*e[0][0],Math.abs(c[2]*h[1][2]-c[1]*h[2][2])>s+r)||(s=i.e[0]*e[2][0]+i.e[2]*e[0][0],r=a.e[1]*e[1][2]+a.e[2]*e[1][1],Math.abs(c[0]*h[2][0]-c[2]*h[0][0])>s+r)||(s=i.e[0]*e[2][1]+i.e[2]*e[0][1],r=a.e[0]*e[1][2]+a.e[2]*e[1][0],Math.abs(c[0]*h[2][1]-c[2]*h[0][1])>s+r)||(s=i.e[0]*e[2][2]+i.e[2]*e[0][2],r=a.e[0]*e[1][1]+a.e[1]*e[1][0],Math.abs(c[0]*h[2][2]-c[2]*h[0][2])>s+r)||(s=i.e[0]*e[1][0]+i.e[1]*e[0][0],r=a.e[1]*e[2][2]+a.e[2]*e[2][1],Math.abs(c[1]*h[0][0]-c[0]*h[1][0])>s+r)||(s=i.e[0]*e[1][1]+i.e[1]*e[0][1],r=a.e[0]*e[2][2]+a.e[2]*e[2][0],Math.abs(c[1]*h[0][1]-c[0]*h[1][1])>s+r)||(s=i.e[0]*e[1][2]+i.e[1]*e[0][2],r=a.e[0]*e[2][1]+a.e[1]*e[2][0],Math.abs(c[1]*h[0][2]-c[0]*h[1][2])>s+r))}intersectsPlane(t){this.rotation.extractBasis(S,y,m);const o=this.halfSize.x*Math.abs(t.normal.dot(S))+this.halfSize.y*Math.abs(t.normal.dot(y))+this.halfSize.z*Math.abs(t.normal.dot(m)),s=t.normal.dot(this.center)-t.constant;return Math.abs(s)<=o}intersectRay(t,o){return this.getSize(B),P.setFromCenterAndSize(l.set(0,0,0),B),d.setFromMatrix3(this.rotation),d.setPosition(this.center),g.copy(d).invert(),R.copy(t).applyMatrix4(g),R.intersectBox(P,o)?o.applyMatrix4(d):null}intersectsRay(t){return this.intersectRay(t,l)!==null}fromBox3(t){return t.getCenter(this.center),t.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(t){return t.center.equals(this.center)&&t.halfSize.equals(this.halfSize)&&t.rotation.equals(this.rotation)}applyMatrix4(t){const o=t.elements;let s=l.set(o[0],o[1],o[2]).length();const r=l.set(o[4],o[5],o[6]).length(),n=l.set(o[8],o[9],o[10]).length();t.determinant()<0&&(s=-s),z.setFromMatrix4(t);const x=1/s,M=1/r,p=1/n;return z.elements[0]*=x,z.elements[1]*=x,z.elements[2]*=x,z.elements[3]*=M,z.elements[4]*=M,z.elements[5]*=M,z.elements[6]*=p,z.elements[7]*=p,z.elements[8]*=p,this.rotation.multiply(z),this.halfSize.x*=s,this.halfSize.y*=r,this.halfSize.z*=n,l.setFromMatrixPosition(t),this.center.add(l),this}}const F=new V;export{V as O};
