import{aH as B,a4 as T,a3 as A,B as S,b as G,am as z,aI as R,aA as w,a8 as U,g as p,aJ as v,k as H,Z as k}from"./ThreeHelper-DQm0ufBX.js";function C(t,n=!1){const e=t[0].index!==null,f=new Set(Object.keys(t[0].attributes)),r=new Set(Object.keys(t[0].morphAttributes)),l={},s={},c=t[0].morphTargetsRelative,a=new S;let g=0;for(let i=0;i<t.length;++i){const m=t[i];let u=0;if(e!==(m.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const o in m.attributes){if(!f.has(o))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+o+'" attribute exists among all geometries, or in none of them.'),null;l[o]===void 0&&(l[o]=[]),l[o].push(m.attributes[o]),u++}if(u!==f.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes."),null;if(c!==m.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const o in m.morphAttributes){if(!r.has(o))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries."),null;s[o]===void 0&&(s[o]=[]),s[o].push(m.morphAttributes[o])}if(n){let o;if(e)o=m.index.count;else if(m.attributes.position!==void 0)o=m.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute"),null;a.addGroup(g,o,i),g+=o}}if(e){let i=0;const m=[];for(let u=0;u<t.length;++u){const o=t[u].index;for(let d=0;d<o.count;++d)m.push(o.getX(d)+i);i+=t[u].attributes.position.count}a.setIndex(m)}for(const i in l){const m=y(l[i]);if(!m)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+i+" attribute."),null;a.setAttribute(i,m)}for(const i in s){const m=s[i][0].length;if(m===0)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[i]=[];for(let u=0;u<m;++u){const o=[];for(let h=0;h<s[i].length;++h)o.push(s[i][h][u]);const d=y(o);if(!d)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+i+" morphAttribute."),null;a.morphAttributes[i].push(d)}}return a}function y(t){let n,e,f,r=-1,l=0;for(let g=0;g<t.length;++g){const i=t[g];if(n===void 0&&(n=i.array.constructor),n!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(e===void 0&&(e=i.itemSize),e!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(f===void 0&&(f=i.normalized),f!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(r===-1&&(r=i.gpuType),r!==i.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;l+=i.count*e}const s=new n(l),c=new G(s,e,f);let a=0;for(let g=0;g<t.length;++g){const i=t[g];if(i.isInterleavedBufferAttribute){const m=a/e;for(let u=0,o=i.count;u<o;u++)for(let d=0;d<e;d++){const h=i.getComponent(u,d);c.setComponent(u+m,d,h)}}else s.set(i.array,a);a+=i.count*e}return r!==void 0&&(c.gpuType=r),c}function P(t,n){if(n===B)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(n===T||n===A){let e=t.getIndex();if(e===null){const s=[],c=t.getAttribute("position");if(c!==void 0){for(let a=0;a<c.count;a++)s.push(a);t.setIndex(s),e=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const f=e.count-2,r=[];if(n===T)for(let s=1;s<=f;s++)r.push(e.getX(0)),r.push(e.getX(s)),r.push(e.getX(s+1));else for(let s=0;s<f;s++)s%2===0?(r.push(e.getX(s)),r.push(e.getX(s+1)),r.push(e.getX(s+2))):(r.push(e.getX(s+2)),r.push(e.getX(s+1)),r.push(e.getX(s)));r.length/3!==f&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const l=t.clone();return l.setIndex(r),l.clearGroups(),l}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",n),t}function I(t,n,e){let{x:f,y:r,z:l}=b(n);const s=new z({transparent:!0,map:t,alphaTest:.4,depthFunc:R}),c=new w(s);return c.position.set(f,r,l),c.scale.set(e,e,1),c.center.set(.5,0),c}function b(t){var n=new U().setFromObject(t);let e=n.getCenter(new p),f=n.getSize(new p),r=e.x,l=e.y+f.y/2,s=e.z;return{x:r,y:l,z:s}}function X(t,n,e="#fff"){t.width=t.height=265*2;const r=t.getContext("2d"),l=2,s=52,c=70;r.clearRect(0,0,t.width,t.height),r.translate(0,t.height-l*(s+c)),r.scale(l,l),r.fillStyle="rgba(8, 10, 12, 0.904)",E(r,0,0,265,s,10),r.fill(),r.strokeStyle=e,r.lineWidth=2,E(r,0,0,265,s,10),r.stroke(),r.lineWidth=2,r.fillStyle=e,r.beginPath(),r.moveTo(265/2,s),r.lineTo(265/2,s+c),r.stroke(),r.closePath();let a=10,g=10,i=[],m=[];n.forEach(o=>{o.align==="left"?i.push(o):m.push(o)}),i.forEach(o=>{x(r,o.text,a,s/2,o.fontSize,o.color,o.fontBold),a+=r.measureText(o.text).width}),m.reverse().forEach(o=>{r.font=`${o.fontSize}px normal Arial`;let d=r.measureText(o.text).width;g+=d+5,x(r,o.text,265-g,s/2,o.fontSize,o.color,o.fontBold)}),r.setTransform(1,0,0,1,0,0);const u=new v(t);return u.minFilter=H,u.wrapS=u.wrapT=k,u}function x(t,n,e,f,r=16,l="#fff",s){t.beginPath(),t.font=`${r}px normal Arial`,t.fillStyle=l,t.textAlign="left",t.textBaseline="middle",t.fillText(n,e,f),s&&t.fillText(n,e,f),t.closePath()}function E(t,n,e,f,r,l){t.beginPath(),t.moveTo(n+l,e),t.lineTo(n+f-l,e),t.quadraticCurveTo(n+f,e,n+f,e+l),t.lineTo(n+f,e+r-l),t.quadraticCurveTo(n+f,e+r,n+f-l,e+r),t.lineTo(n+l,e+r),t.quadraticCurveTo(n,e+r,n,e+r-l),t.lineTo(n,e+l),t.quadraticCurveTo(n,e,n+l,e),t.closePath()}function O(t,n,e,f,r,l,s){let c=[];switch(t){case"PRESSURE":const a=l===r?"pressure":"temp";if(e[a]&&e[a]!==void 0){const u=`${e[a]}${a=="pressure"?"kPa":"°C"}`;f[a]?f[a].value=u:f[a]={order:a==="pressure"?1:2,value:u}}let i=Object.values(f).sort((u,o)=>u.order-o.order).map(u=>u.value);c=[{text:`${n}`,align:"left",fontSize:16,color:"#fff",fontBold:!0},{text:i.join(" | "),align:"right",fontSize:16,color:"#fff",fontBold:!0}];break;case"UNIT":{let u=e.temp_cold_set,o=[{text:n,align:"left",color:"#fff",fontSize:16,fontBold:!0}];u&&(o.push({text:"设定温度",align:"right",color:"rgba(255,255,255,0.7)",fontSize:12,fontBold:!1}),o.push({text:`${e.temp_cold_set}°C`,align:"right",color:"#fff",fontSize:16,fontBold:!0})),c=o;break}case"TOWER":c=[{text:n,color:"#fff",align:"left",fontSize:16,fontBold:!0}];break;case"FREEZE":case"COOLANT":{const u=e.freqset;let o=[{text:n,color:"#fff",align:"left",fontSize:16,fontBold:!0}];u&&(o.push({text:"设定频率",align:"right",color:"rgba(255,255,255,0.7)",fontSize:12,fontBold:!1}),o.push({text:u+"Hz",color:"#fff",align:"right",fontSize:16,fontBold:!0})),c=o;break}default:c=[];break}return s&&c.push({text:"故障",align:"right",color:"#f50616",fontSize:16,fontBold:!0}),c}function j(t,n){const e=new w(t);e.center.set(.5,.5);const{x:f,y:r,z:l}=b(n);return e.position.set(f,r,l),e.material.dir="toBig",e}function D(t,n){let e=t;for(;!n(e);)if(e=e.parent,e===null)return null;return e}function M(t,n,e){const{x:f,y:r,z:l}=b(t),c=new p(f,r,l).project(n),a=e.clientWidth/2,g=e.clientHeight/2,i=Math.round(c.x*a+a),m=Math.round(-c.y*g+g);return{x:i,y:m}}export{X as a,I as b,j as c,M as d,D as f,O as g,C as m,P as t};
